document
	= _ source:command_set { return source; }

// Command set (Top level document)
command_set
	= commands:command* {
		return commands.reduce(function(a,b) { return a.concat(b); }, []);
	}

command
	= ":" _ i:identifier { return { line: line, column: column, type: "label", name: i }; }
	/ i:identifier ":" _  { return { line: line, column: column, type: "label", name: i }; }
	/ op:identifier args:expression_list { return { line: line, column: column, type: "operation", name: op, arguments: args }; }
	/ directive

directive
	= procedure
	/ include
	/ macro
	/ data_block
	/ equate_directive
	/ directive:valid_directive value:expression { return { line: line, column: column, type: directive, value: value }; }
	
valid_directive
	= ".org"i _ { return "org"; }
	/ ".bss"i _ { return "bss"; }
	/ ".ds"i _ { return "bss"; }
	/ ".align"i _ { return "align"; }

equate_directive
	= ".equ"i _ name:identifier value:expression { return { line: line, column: column, type: "equate", name: name, value: value }; }

data_block
	= data_type:data_type args:expression_list {
		args = args.reduce(function(list, v) {
			if (v.type === "string") {
				v = v.value.split('').map(function(c) { 
					return { line: v.line, column: v.column, type: "number", value:c.charCodeAt(0) };
				});
			}
			return list.concat(v);
		}, []);

		var null_byte = {
			number: 0,
			type: 'number'
		}, remap = [],
		i;

		switch (data_type) {
			case '.little':
				for(i = 0; i < args.length; i += 2) {
					remap.push({
						type: "binary",
						operation: "#",
						left: args[i],
						right: args[i+1] || null_byte
					});
				}
				break ;
			case '.big':
				for(i = 0; i < args.length; i += 2) {
					remap.push({
						type: "binary",
						operation: "#",
						left: args[i+1] || null_byte,
						right: args[i]
					});
				}
				break ;
			default:
				remap = args;
				break;
		}

		return { line: line, column: column, type:'data', arguments: remap };
	}

data_type
	= ".data"i _
	/ ".dat"i _
	/ ".big"i _
	/ ".little"i _

include_types
	= ".include"i _ {
		return function (line, column, file) {
			return global.parser.parse(file.toString("utf8"));
		}
	}
	/ ".incbig"i _ {
		return function (line, column, file) {
			var data = [];
			for (i = 0; i < file.length; i+=2) { 
				data[i/2] = { type: 'number', value: file.readUInt16BE(i, true) };
			}
			return { line: line, column: column, type: "data", arguments:data }
		}
	}
	/ ".inclittle"i _ {
		return function (line, column, file) {
			var data = [];
			for (i = 0; i < data.length; i+=2) { 
				data[i/2] = { type: 'number', value: file.readUInt16LE(i, true) };
			}
			return { line: line, column: column, type: "data", arguments:data }
		}
	}
	/ ".incbytes"i _ {
		return function (line, column, file) {
			var data = [];
			for (i = 0; i < file.length; i++) { 
				data[i] = { type: 'number', value: file[i] };
			}
			return { line: line, column: column, type: "data", arguments:data }
		}
	}

include
	= parser:include_types args:expression_list {
		var context = global.parser,
			active = context.active || (context.active = []);

		return args.reduce(function (added, a) {
			if (a.type !== 'string') {
				throw new Error("Include requires a string argument");
			}
			
			var fn = a.value,
				before = active.concat();
			if (active.indexOf(fn) >= 0) {
				throw new Error("Recursive inclusion of " + fn);
			}

			active.push(fn);
			var result = parser(line, column, require("fs").readFileSync(fn));
			active.pop();

			return added.concat(result);
		}, []);
	}

macro 
	= ".macro"i _ name:identifier params:identifier_list commands:command_set ".end" _ { 
		return { line: line, column: column, type: "macro", name: name, parameters: params, contents: commands };
	}

// Auto-escape identifiers which have been wrapped in a proc block
procedure
	= ".proc"i _ commands:command_set ".end"i _ {
		var context = global.parser,
			_suffix = "$p" + ((context.index) ? (context.index++) : (context.index = 0));

		function suffix(v) {
			return v + ((v[0] === '_') ? _suffix : '');
		}

		function walk(element) {
			if (Array.isArray(element)) { 
				element.forEach(walk); 
				return ; 
			}

			switch (element.type) {
				case 'data':
					walk(element.arguments);
					break;
				case 'align':
				case 'bss':
				case 'org':
					walk(element.value);
					break ;
				case 'equate':
					element.name = suffix(element.name);
					walk(element.value);
					break ;				
				case 'macro':
					element.name = suffix(element.name);
					element.parameters = element.parameters.map(suffix);
					walk(element.contents);
					break ;
				case 'operation':
					element.name = suffix(element.name);
					walk(element.arguments);
					break ;
				case 'label':
					element.name = suffix(element.name);
					break ;
				case 'identifier':
					element.name = suffix(element.name);
					break ;
				case 'unary':
					walk(element.term);
					break ;
				case 'binary':
					walk(element.left);
					walk(element.right);
					break ;
				case 'number':
				case 'string':
					break ;
				default:
					throw new Error("Could not process block " + element.name)
					break ;
			}
		}

		walk(commands);
		return commands;
	}

// Collections
identifier_list
	= a:(identifier "," _)* b:identifier { return a.map(function(g) { return g[0]; }).concat(b); }

expression_list
	= a:(expression "," _)* b:expression { return a.map(function(g) { return g[0]; }).concat(b); }


// Expressions
expression
	= l:short_exp op:binary_op _ r:expression { return { line: line, column: column, type: "unordered", operation: op, left: l, right: r } }
	/ p:short_exp

short_exp
	= "(" _ o:expression ")" _ { return { line: line, column: column, type: "paren", term: o }; }
	/ "[" _ e:expression "]" _ { return { line: line, column: column, type: "address", expression: e } }
	/ op:unary_op _ t:short_exp { return { line: line, column: column, type: "unary", operation: op, term: t } }
	/ s:string { return { line: line, column: column, type: "string", value:s } }
	/ n:number { return { line: line, column: column, weight: 1, type: "number", value:n } }
	/ c:character { return { line: line, column: column, weight: 1, type: "number", value:c } }
	/ r:register { return { line: line, column: column, weight: 3, type: "register", name:r } }
	/ i:identifier { return { line: line, column: column, weight: 2, type: "identifier", name:i } }

// Operators
binary_op
	= op:"+"  { return { line: line, column: column, operation: op, priority: 5, reorder: "full" }; }
	/ op:"-"  { return { line: line, column: column, operation: op, priority: 5, reorder: "partial" }; }
	/ op:"/"  { return { line: line, column: column, operation: op, priority: 6, reorder: "partial" }; }
	/ op:"*"  { return { line: line, column: column, operation: op, priority: 6, reorder: "full" }; }
	/ op:"%"  { return { line: line, column: column, operation: op, priority: 6 }; }
	/ op:"<<" { return { line: line, column: column, operation: op, priority: 3 }; }
	/ op:">>" { return { line: line, column: column, operation: op, priority: 3 }; }
	/ op:"||" { return { line: line, column: column, operation: op, priority: 2 }; }
	/ op:"&&" { return { line: line, column: column, operation: op, priority: 1 }; }
	/ op:"^"  { return { line: line, column: column, operation: op, priority: 4, reorder: "full" }; }
	/ op:"|"  { return { line: line, column: column, operation: op, priority: 4, reorder: "full" }; }
	/ op:"&"  { return { line: line, column: column, operation: op, priority: 4, reorder: "full" }; }
	/ op:"#"  { return { line: line, column: column, operation: op, priority: 4 }; }

unary_op
	= "+"
	/ "-"
	/ "~"
	/ "&"

// Primitive values
string
	= '"' s:string_char* '"' _ { return s.join(""); }

string_char
	= [^"\\\n\r]
	/ "\\n" { return "\n"; }
	/ "\\r" { return "\r"; }
	/ "\\t" { return "\t"; }
	/ "\\b" { return "\b"; }
	/ "\\f" { return "\f"; }
	/ "\\\\" { return "\\"; }
	/ "\\x" v:[0-9a-f]i+ { return String.fromCharCode(parseInt(v, 16)); }
	/ "\\u" v:[0-9a-f]i+ { return String.fromCharCode(parseInt(v, 16)); }

character
	= "'" v:. "'" _ { return v.charCodeAt(0); }

number
	= "0x"i v:[0-9a-f]i+ _ { return parseInt(v.join(''), 16); }
	/ "0b"i v:[0-9a-f]i+ _ { return parseInt(v.join(''), 2); }
	/ "0"i v:[0-7]i+ _ { return parseInt(v.join(''), 8); }
	/ "0" _ { return 0; }
	/ "$" v:[0-9a-f]i+ _ { return parseInt(v.join(''), 16); }
	/ v:[0-9]+ _ { return parseInt(v.join(''), 10); }

register
	= "a"i _ { return "A"; }
	/ "b"i _ { return "B"; }
	/ "c"i _ { return "C"; }
	/ "x"i _ { return "X"; }
	/ "y"i _ { return "Y"; }
	/ "z"i _ { return "Z"; }
	/ "i"i _ { return "I"; }
	/ "j"i _ { return "J"; }
	/ "pc"i _ { return "PC"; }
	/ "sp"i _ { return "SP"; }
	/ "ex"i _ { return "EX"; }
	/ "push"i _ { return "PUSH"; }
	/ "pop"i _ { return "POP"; }

identifier
	= a:[_a-z]i b:[_a-z0-9]i* _ { return a + b.join(""); }

// Whitespace and Comments
_ 
	= whitespace* { return { line: line, column: column, type: "whitespace" }; }

whitespace
	= [\n\r\t ]+
	/ "/*" multiline_comment* "*/"
	/ "//" [^\n\r]*
	/ ";" [^\n\r]*

multiline_comment
	= [^*]
	/ "*" &[^/]
