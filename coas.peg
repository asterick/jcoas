document
	= source:command_set { return source; }

// Command set (Top level document)
command_set
	= _ commands:command* _ {
		return commands.reduce(function(a,b) { return a.concat(b); }, []);
	}

command
	= ":" _ i:identifier _ { return { line: line, column: column, type: "label", name: i }; }
	/ i:identifier _ ":" _  { return { line: line, column: column, type: "label", name: i }; }
	/ op:identifier args:expression_list _ { return { line: line, column: column, type: "operation", name: op, arguments: args }; }
	/ directive

directive
	= procedure
	/ include
	/ macro
	/ data_block
	/ equate_directive
	/ directive:valid_directive _  value:ordered_expression { return { line: line, column: column, type: directive, value: value }; }
	
valid_directive
	= ".org"i { return "org"; }
	/ ".bss"i { return "bss"; }
	/ ".ds"i { return "bss"; }
	/ ".align"i { return "align"; }

equate_directive
	= ".equ"i _ name:identifier value:ordered_expression { return { line: line, column: column, type: "equate", name: name, value: value }; }

data_block
	= data_type:data_type _ args:expression_list {
		args = args.reduce(function(list, v) {
			if (v.type === "string") {
				v = v.value.split('').map(function(c) { 
					return { line: v.line, column: v.column, type: "number", value:c.charCodeAt(0) };
				});
			}
			return list.concat(v);
		}, []);

		var null_byte = {
			number: 0,
			type: 'number'
		}, remap = [],
		i;

		switch (data_type) {
			case '.little':
				for(i = 0; i < args.length; i += 2) {
					remap.push({
						type: "binary",
						operation: "#",
						left: args[i],
						right: args[i+1] || null_byte
					});
				}
				break ;
			case '.big':
				for(i = 0; i < args.length; i += 2) {
					remap.push({
						type: "binary",
						operation: "#",
						left: args[i+1] || null_byte,
						right: args[i]
					});
				}
				break ;
			default:
				remap = args;
				break;
		}

		return { line: line, column: column, type:'data', arguments: remap };
	}

data_type
	= ".data"
	/ ".dat"i
	/ ".big"i
	/ ".little"i

include_types
	= ".include"i {
		return function (line, column, file) {
			return global.parser.parse(file.toString("utf8"));
		}
	}
	/ ".incbig"i {
		return function (line, column, file) {
			var data = new Uint16Array((file.length +1) / 2);
			for (i = 0; i < data.length; i++) { 
				data[i] = file.readUInt16BE(i*2, true);
			}
			return { line: line, column: column, type: "compiled", data:data }
		}
	}
	/ ".inclittle"i {
		return function (line, column, file) {
			var data = new Uint16Array((file.length +1) / 2);
			for (i = 0; i < data.length; i++) { 
				data[i] = file.readUInt16LE(i*2, true);
			}
			return { line: line, column: column, type: "compiled", data:data }
		}
	}
	/ ".incbytes"i {
		return function (line, column, file) {
			var data = new Uint16Array(file.length);
			for (i = 0; i < data.length; i++) { 
				data[i] = file[i];
			}
			return { line: line, column: column, type: "compiled", data:data }
		}
	}

include
	= parser:include_types _ args:expression_list {
		var context = global.parser,
			active = context.active || (context.active = []);

		return args.reduce(function (added, a) {
			if (a.type !== 'string') {
				throw new Error("Include requires a string argument");
			}
			
			var fn = a.value,
				before = active.concat();
			if (active.indexOf(fn) >= 0) {
				throw new Error("Recursive inclusion of " + fn);
			}

			active.push(fn);
			var result = parser(line, column, require("fs").readFileSync(fn));
			active.pop();

			return added.concat(result);
		}, []);
	}

macro 
	= ".macro"i _ name:identifier params:identifier_list commands:command_set _ ".end" _ { 
		return { line: line, column: column, type: "macro", name: name, parameters: params, contents: commands };
	}

// Auto-escape identifiers which have been wrapped in a proc block
procedure
	= ".proc"i _ commands:command_set ".end"i _ {
		var context = global.parser,
			_suffix = "$p" + ((context.index) ? (context.index++) : (context.index = 0));

		function suffix(v) {
			return v + ((v[0] === '_') ? _suffix : '');
		}

		function walk(element) {
			if (Array.isArray(element)) { 
				element.forEach(walk); 
				return ; 
			}

			switch (element.type) {
				case 'data':
					walk(element.arguments);
					break;
				case 'align':
				case 'bss':
				case 'org':
					walk(element.value);
					break ;
				case 'equate':
					element.name = suffix(element.name);
					walk(element.value);
					break ;				
				case 'macro':
					element.name = suffix(element.name);
					element.parameters = element.parameters.map(suffix);
					walk(element.contents);
					break ;
				case 'operation':
					element.name = suffix(element.name);
					walk(element.arguments);
					break ;
				case 'label':
					element.name = suffix(element.name);
					break ;
				case 'identifier':
					element.name = suffix(element.name);
					break ;
				case 'unary':
					walk(element.term);
					break ;
				case 'binary':
					walk(element.left);
					walk(element.right);
					break ;
				case 'compiled':
				case 'number':
				case 'string':
					break ;
				default:
					throw new Error("Could not process block " + element.name)
					break ;
			}
		}

		walk(commands);
		return commands;
	}

// Collections
identifier_list
	= _ "(" _ i:identifier_list _ ")" _ { return i; }
	/ a:(identifier _ "," _)* b:identifier { return a.map(function(g) { return g[0]; }).concat(b); }

expression_list
	= _ "(" _ i:expression_list _ ")" _ { return i; }
	/ a:(ordered_expression _ "," _)* b:ordered_expression { return a.map(function(g) { return g[0]; }).concat(b); }


// Expressions (ordered expression handles priority encoding)
ordered_expression
	= node:expression { 
		if (node.type !== "unordered_binary") {
			return node;
		}

		// Collapse chain into a couple lists for ease of use
		var values = [],
			operations = [],
			index = 0;

		do {
			node.operation.index = index++;
			operations.push(node.operation);
			values.push(node.left);

			node = node.right;
		} while(node.type === "unordered_binary");
		values.push(node);
		
		// Sort operations in order of their priority
		// TODO: Try to group up numbers in like operations
		operations.sort(function(a, b) { return b.priority - a.priority; });

		// ... and then collapse value tree into binary operations
		operations.forEach(function(o, i) {
			var index = o.index;
			operations.slice(i+1).forEach(function(o) {
				if(index < o.index) { o.index-- }
			});
			values.splice(index, 2, {
				line: o.line,
				column: o.column,
				type: "binary",
				operation: o.operation,
				left: values[index],
				right: values[index+1]
			})
		});

		return values[0];
	}

expression
	= l:short_exp _ op:binary_op _ r:expression { return { line: line, column: column, type: "unordered_binary", operation: op, left: l, right: r } }
	/ p:short_exp _  { return p; }

short_exp
	= "(" _ o:ordered_expression _ ")" _ { return o; }
	/ "[" _ e:ordered_expression _ "]" _ { return { line: line, column: column, type: "address", expression: e } }
	/ op:unary_op _ t:short_exp { return { line: line, column: column, type: "unary", operation: op, term: t } }
	/ n:number { return { line: line, column: column, type: "number", value:n } }
	/ s:string { return { line: line, column: column, type: "string", value:s } }
	/ c:character { return { line: line, column: column, type: "number", value:c } }
	/ i:identifier { return { line: line, column: column, type: "identifier", name:i } }

// Operators
binary_op
	= op:"+"  { return { line: line, column: column, operation: op, priority: 5 }; }
	/ op:"-"  { return { line: line, column: column, operation: op, priority: 5 }; }
	/ op:"/"  { return { line: line, column: column, operation: op, priority: 6 }; }
	/ op:"*"  { return { line: line, column: column, operation: op, priority: 6 }; }
	/ op:"%"  { return { line: line, column: column, operation: op, priority: 6 }; }
	/ op:"<<" { return { line: line, column: column, operation: op, priority: 3 }; }
	/ op:">>" { return { line: line, column: column, operation: op, priority: 3 }; }
	/ op:"||" { return { line: line, column: column, operation: op, priority: 2 }; }
	/ op:"&&" { return { line: line, column: column, operation: op, priority: 1 }; }
	/ op:"^"  { return { line: line, column: column, operation: op, priority: 4 }; }
	/ op:"|"  { return { line: line, column: column, operation: op, priority: 4 }; }
	/ op:"&"  { return { line: line, column: column, operation: op, priority: 4 }; }
	/ op:"#"  { return { line: line, column: column, operation: op, priority: 4 }; }

unary_op
	= "+"
	/ "-"
	/ "~"
	/ "&"

// Primitive values
string
	= '"' s:string_char* '"' { return s.join(""); }

string_char
	= [^"\\\n\r]
	/ "\\n" { return "\n"; }
	/ "\\r" { return "\r"; }
	/ "\\t" { return "\t"; }
	/ "\\b" { return "\b"; }
	/ "\\f" { return "\f"; }
	/ "\\\\" { return "\\"; }
	/ "\\x" v:[0-9a-f]i+ { return String.fromCharCode(parseInt(v, 16)); }
	/ "\\u" v:[0-9a-f]i+ { return String.fromCharCode(parseInt(v, 16)); }

character
	= "'" v:. "'" { return v.charCodeAt(0); }

number
	= "0x"i v:[0-9a-f]i+ { return parseInt(v.join(''), 16); }
	/ "0b"i v:[0-9a-f]i+ { return parseInt(v.join(''), 2); }
	/ "0"i v:[0-7]i+ { return parseInt(v.join(''), 8); }
	/ "0" { return 0; }
	/ "$" v:[0-9a-f]i+ { return parseInt(v.join(''), 16); }
	/ v:[0-9]+ { return parseInt(v.join(''), 10); }

identifier
	= _ a:[_a-z]i b:[_a-z0-9]i* _ { return a + b.join(""); }

// Whitespace and Comments
_ 
	= whitespace* { return { line: line, column: column, type: "whitespace" }; }

whitespace
	= [\n\r\t ]+
	/ "/*" multiline_comment* "*/"
	/ "//" [^\n\r]*
	/ ";" [^\n\r]*

multiline_comment
	= [^*]
	/ "*" &[^/]
